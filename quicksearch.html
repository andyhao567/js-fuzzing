<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"cooker.js.html":{"id":"cooker.js.html","title":"Source: cooker.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Source: cooker.js var _ = require(&quot;./lodash-wrapper.js&quot;); var traverse = require(&quot;traverse&quot;); var pd = require(&quot;probability-distributions&quot;); var { MandGTypeManager } = require(&quot;./mandg.js&quot;); /** * takes a `thing` object and a bunch of random numbers and * spits out a Recipe */ class Cooker { /** * Cooker constructor * @param {object} opts - options for the new cooker * @param {string} opts.numPathsDistribution - when selecting the number of paths from `thing` to mangle, this is the distribution. Options are &quot;low&quot;, &quot;uniform&quot; or &quot;split&quot;. Low is more likely to pick a low number of paths (e.g. - 1 or 2), uniform is likely to pick any number of paths, and split is likely to pick a low number or the max number. */ constructor(opts) { opts = opts || {}; var defaults = { numPathsDistribution: &quot;low&quot;, weightMap: new Map([ [&quot;generate&quot;, 3], [&quot;mutate&quot;, 3], [&quot;generateAny&quot;, 1], [&quot;mutateByParent&quot;, 1] ]) }; _.defaultsDeep(opts, defaults); this.numPathsDistribution = opts.numPathsDistribution; this.weightMap = opts.weightMap; // calculated in init this.weightedOpList = []; } /** * initializes the Cooker with a `thing` object and does any configuration necessary * @param {any} thing - the object, string, array, null, or whatever that will be mangled by the fuzzer */ init(thing) { // save thing for later this.thing = _.cloneDeep(thing); // adds one entry of a function for every weight count for (let weightType of this.weightMap) { var weight = weightType[1]; var functionName = weightType[0]; for (let i = 0; i &lt; weight; i++) { this.weightedOpList.push(functionName); } } // create the path list this.pathList = _.invokeMap(traverse(thing).paths(), Array.prototype.join, &quot;.&quot;); // mark initialization as complete this.initialized = true; // add generateAny to the context of any calling function new MandGTypeManager().addToContext(&quot;generateAny&quot;, this.generateAny); return this; } getRandomPathCount(max) { pd.prng = Math.random; // three options: switch (this.numPathsDistribution) { case &quot;uniform&quot;: // 1. uniform distribution return _.random(1, max); case &quot;low&quot;: // 2. low-number heavy distribution return pd.rbinom(1, max - 1, 0.1)[0] + 1; case &quot;split&quot;: // 3. split between min and max, with an even sprinkling inbetween return (Math.ceil(pd.rbeta(1, 0.5, 0.6)[0] * max - 1)) + 1; } } selectPaths() { var list = this.pathList; if (list.length === 1) return list; var count = this.getRandomPathCount(list.length); return _.sampleSize(list, count); } selectOp(mandg) { var op; var opGenerator; do { opGenerator = _.sample(this.weightedOpList); op = this[opGenerator](mandg); } while (!op); return op; } generate(mandg) { return _.sample(mandg.generator); } mutate(mandg) { return _.sample(mandg.mutator); } generateAny() { if (this.generateAnyCache) return _.sample(this.generateAnyCache); var mgr = new MandGTypeManager(); var genList = []; gatherGenerators (mgr.root); // recursively iterates all MandG to create a list of all generators function gatherGenerators(mandg) { // add all generators from this MandG to the list for (let gen of Object.keys(mandg.generator)) { genList.push (mandg.generator[gen]); } // iterate all subtypes for (let sub of Object.keys(mandg.subtype)) { gatherGenerators (mandg.subtype[sub]); } } this.generateAnyCache = genList; new MandGTypeManager().addToContext(&quot;generateAnyCache&quot;, this.generateAnyCache); return _.sample(this.generateAnyCache); } mutateByParent(mandg) { var mutateList = []; while (mandg) { for (let mut of Object.keys(mandg.mutator)) { mutateList.push(mandg.mutator[mut]); } mandg = mandg.parent; } return _.sample(mutateList); } createRecipe() { var mgr = new MandGTypeManager(); if (!this.initialized) { throw new Error(&quot;Initialize cooker before calling createRecipe&quot;); } // console.log (&quot;path list:&quot;, this.pathList); var selectedPaths = this.selectPaths(); // console.log (&quot;selected paths:&quot;, selectedPaths); var recipe = new Recipe(); for (let path of selectedPaths) { // extract the specific item from the path in the thing object var item = (path === &quot;&quot;) ? this.thing : _.get(this.thing, path); // find the matching mandg for the thing var mandg = mgr.resolveType(item); // find the operation we want to perform var op = this.selectOp(mandg); recipe.addStep(path, op); } return recipe; } } /** * A single step in a Recipe */ class Step { constructor(path, op) { this.path = path; this.op = op; } } /** * The recipe instructs the Fuzzer what steps to take to mutate a `thing` */ class Recipe { constructor() { // this.length this.steps = new Set(); // this.steps = [{path: &quot;&quot;, operation: &quot;&quot;}] this.recipeIterator = function*() { for (let step of this.steps) { yield step; } }; } /** * Get the number of steps in the recipe * @returns {Number} length of the recipe */ get length() { return this.steps.size; } /** * Adds a step to this receipe * @param pathOrStep {String|Step} - the path in `thing` that `op` will run on. Or if a Step has already been created (which constains a path and op) just use that instead. * @param op {Function} - if pathOrStep is a path, this is the function that will be run against that path */ addStep(pathOrStep, op) { console.log(`adding step :: path: &quot;${pathOrStep}&quot; ; op: ${op.name}`); var step; if (pathOrStep instanceof Step) { step = pathOrStep; } else { step = new Step(pathOrStep, op); } this.steps.add(step); } /** * Implements the next() part of the iterator protocol */ [Symbol.iterator]() { return this.recipeIterator(); } // toString } module.exports = { Cooker: Cooker, Recipe: Recipe }; × Search results Close "},"fuzz.js.html":{"id":"fuzz.js.html","title":"Source: fuzz.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Source: fuzz.js var _ = require(&quot;./lodash-wrapper&quot;); // var MandG = require(&quot;./mandg.js&quot;).MandG; // var { // debug, // Cooker // } = require(&quot;../index.js&quot;); var { debug } = require(&quot;./debug.js&quot;); var { Cooker } = require(&quot;./cooker.js&quot;); /** * The main class for operating the Fuzzer * @param {any} thing - the object, string, array, null, or whatever that will be mangled by the fuzzer */ class Fuzz { constructor(thing, opts) { opts = opts || {}; var defaults = { seed: new Date().getTime(), cooker: new Cooker(), }; // resolve default values vs. passed in options _.defaultsDeep(opts, defaults); // reseed the PRNG this.seed = opts.seed; _.reseed(this.seed); debug (&quot;PRNG Seed:&quot;, this.seed); // save the 'thing' for later this.thing = _.cloneDeep(thing); // create the cooker this.cooker = opts.cooker; this.cooker.init(thing); // if (opts.debug) { debug.on(); // } } run() { // set timeout // call // catch error // -- return, cb, promise // see if error is okay // if no error, validate results } fuzz() { var thing = _.cloneDeep(this.thing); var recipe = this.cooker.createRecipe(thing, this.pathList, this.types); for (let step of recipe) { var path = step.path; var op = step.op; var victim = path===&quot;&quot;?thing:_.get(thing, path); console.log (&quot;victim:&quot;, victim); let res = op(victim); // we may have already mangled the path, so setting my result in a dereferencing erro try { _.set(thing, path, res); } catch (err) { debug(`ERROR: ${err.name}: ${err.message} ...`); debug(`... while running op &quot;${op.name}&quot; on path &quot;${path}&quot;`); } } return thing; } } module.exports = { Fuzz: Fuzz }; × Search results Close "},"mandg.js.html":{"id":"mandg.js.html","title":"Source: mandg.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Source: mandg.js var _ = require(&quot;./lodash-wrapper.js&quot;); var DepGraph = require(&quot;dependency-graph&quot;).DepGraph; /** @todo Mutator and Generator should be derived from a common class... too much cut-and-paste code right now */ class MorGBase extends Function { constructor(name, fn, opts) { super(); // check args if (typeof name !== &quot;string&quot;) { throw new TypeError(&quot;Mutator constructor expected 'name' to be string, got:&quot; + name); } if (typeof fn !== &quot;function&quot;) { throw new TypeError(&quot;Mutator constructor expected 'fn' to be function, got:&quot; + typeof fn); } opts = opts || {}; this.tags = []; this.fn = fn; // can't assign to read-only 'name'... // ...but we can sure redefine it! Object.defineProperty(this, &quot;name&quot;, { enumerable: false, configurable: true, writable: false, value: name }); // if we are called, turn around and call fn return new Proxy(this, { apply: (target, thisArg, argumentsList) =&gt; { var ctx = new MandGTypeManager().getContext(); // console.log (&quot;inserting ctx:&quot;, ctx); this.fn.apply(ctx, argumentsList); } }); } fn(thing) { throw new Error(`Mutating ${thing} in ${this.name}: mutator not implemented`); } } /** * Generic Mutator class */ class Mutator extends MorGBase { constructor(name, fn, opts) { // check args if (fn.length !== 1) { throw new TypeError(&quot;Mutator constructor expected 'fn' to have one arg, has: &quot; + fn.length); } super(name, fn, opts); } } /** * Generic Generator class */ class Generator extends MorGBase { constructor(name, fn, opts) { // check args if (fn.length !== 0) { throw new TypeError(&quot;Generator constructor expected 'fn' to have zero args, has: &quot; + fn.length); } super(name, fn, opts); } } /** * Mutators and Generators (MandG) container class * has all the logic around the specific mutators and generators for a specific type */ class MandG { constructor(type, check, opts) { if (typeof type !== &quot;string&quot;) { throw new TypeError(&quot;MandG constructor expected type, got: &quot; + type); } if (typeof check !== &quot;function&quot;) { throw new TypeError(&quot;MandG constructor expected 'check' to be a function, got: &quot; + typeof check); } // set default options opts = opts || {}; var defaults = {}; _.defaultsDeep(opts, defaults); if (!Array.isArray(opts.depends) &amp;&amp; opts.depends !== undefined) { throw new TypeError(&quot;Expected dependencies to be array, got: &quot; + typeof opts.depends); } if (typeof opts.parent !== &quot;string&quot; &amp;&amp; opts.parent !== undefined) { throw new TypeError(&quot;Expected parent to be string, got: &quot; + typeof opts.parent); } this.depends = opts.depends || []; this.parent = opts.parent || undefined; // configure options this.type = type; this.name = type; this.check = check; // for future use // TODO: use Maps? using _.sample() later may not be map friendly this.mutator = {}; this.generator = {}; this.subtype = {}; } check(thing) { throw new Error(`Adding ${thing}: check not implemented`); } addMutator(m) { // if mutator is a function, convert it to the mutator class if (typeof m === &quot;function&quot; &amp;&amp; !(m instanceof Mutator)) { if (!m.name) { throw new TypeError(&quot;attempting to add Mutator from function without a name&quot;); } m = new Mutator(m.name, m); } // check typeof Mutator if (!(m instanceof Mutator)) { throw new TypeError(&quot;addMutator expected type Mutator, got: &quot; + typeof m); } // TODO: check to make sure mutator doesn't already exist? var name = m.name; this.mutator[name] = m; } addGenerator(g) { // if generator is a function, convert it to the generator class if (typeof g === &quot;function&quot; &amp;&amp; !(g instanceof Generator)) { if (!g.name) { throw new TypeError(&quot;attempting to add Generator from function without a name&quot;); } g = new Generator(g.name, g); } // check typeof Generator if (!(g instanceof Generator)) { throw new TypeError(&quot;addGenerator expected type Generator, got: &quot; + typeof g); } // TODO: check to make sure generator doesn't already exist? var name = g.name; this.generator[name] = g; } /** * Reuses a generator that has already been implemented by another module */ borrowGenerator(module, name) { // add module as dependency // add string as &quot;function&quot; in module list // proxy should resolve string to function later... } /** * Reuses a mutator that has already been implemented by another module */ borrowMutator(module, name) { // add module as dependency // add string as &quot;function&quot; in module list // proxy should resolve string to function later... } addSubtype(s) { // check typeof Subtype if (!(s instanceof MandG)) { throw new TypeError(&quot;addSubtype expected type MandG, got: &quot; + typeof s); } if (s === this) { throw new TypeError(&quot;attempting to add MandG to itself: recursion not allowed&quot;); } // TODO: check to make sure type doesn't already exist var name = s.name; if (this.subtype[name] !== undefined) { throw new TypeError(&quot;trying to add duplicate subtype: &quot; + name); } this.subtype[name] = s; } /** * filters mutators and generators based on a specific tag * @todo not implemented */ filter(tag) { throw new Error (&quot;MandG filter not implemented&quot;); } } /** * A singleton for managing all MandG types */ var mandgTypeManagerSingleton; class MandGTypeManager { constructor(opts) { // class is a singleton if (mandgTypeManagerSingleton) return mandgTypeManagerSingleton; mandgTypeManagerSingleton = this; // set default options opts = opts || {}; var defaults = { mandgModuleList: [&quot;array&quot;, &quot;boolean&quot;, &quot;date&quot;, &quot;function&quot;, &quot;null&quot;, &quot;number&quot;, &quot;object&quot;, &quot;regexp&quot;, &quot;string&quot;, &quot;undef&quot;] }; _.defaultsDeep(opts, defaults); // the context for all MandG function calls this.callContext = {}; // a flat list of all types this.typeIndex = {}; // root of the heirarchy of types this.root = new MandG(&quot;everything&quot;, function() { return true; }); this.typeIndex.everything = this.root; // load all the built-in types if (opts.mandgReplacementModules) { this.mandgModuleList = opts.mandgReplacementModules; } else { this.mandgModuleList = opts.mandgModuleList; } var mandg; var dependencyGraph = new DepGraph(); for (let idx in this.mandgModuleList) { mandg = null; // try to load a module that is available in `node_modules` or similar try { mandg = require(this.mandgModuleList[idx]); } catch (err) {} // try to load the module out of our local types directory if (!mandg) try { mandg = require(`./types/${this.mandgModuleList[idx]}.js`); } catch (err) {} // if (!(mandg instanceof MandG)) { // XXX TODO for some reason this is broken if (!mandg) { throw TypeError(&quot;Error loading mandg module: &quot; + this.mandgModuleList[idx]); } // add the node to the dependency graph // note that all nodes have to exist before dependencies can be added dependencyGraph.addNode(mandg.type, mandg); } // map out dependencies // TODO: save this order? replace module list? var list = dependencyGraph.overallOrder(); for (let node of list) { mandg = dependencyGraph.getNodeData(node); if (typeof mandg.parent !== &quot;string&quot; &amp;&amp; mandg.parent !== undefined) { throw new TypeError (`Expected parent to be string when building dependencies for ${mandg.type}. Got: ${typeof mandg.parent}`); } // try to add parent as a dependency if (mandg.parent) { try { dependencyGraph.addDependency(mandg.type, mandg.parent); } catch (err) { throw new TypeError(`parent '${mandg.parent}' not found when loading '${mandg.type}'`); } } // try to add all depends as dependencies for (let depName of mandg.depends) { try { dependencyGraph.addDependency(mandg.type, depName); } catch (err) { throw new TypeError(`dependency '${depName}' not found when loading '${mandg.type}'`); } } } for (let node of dependencyGraph.overallOrder()) { mandg = dependencyGraph.getNodeData(node); this.registerType(mandg); } this.addToContext (&quot;utils&quot;, this.typeIndex); } /** * Kills the singleton so that a new one will be created. * Mostly useful for testing, but maybe other things too. */ forceReset() { // console.log (&quot;RESETTING MANDGTYPEMANAGER&quot;); mandgTypeManagerSingleton = null; } /** * registers a new mandg type * @param newType {MandG} - the new MandG type to register */ registerType(newType) { if (!(newType instanceof MandG)) { throw new TypeError(&quot;expected 'newType' to be of type MandG, was: &quot; + typeof mandg); } var name = newType.type; var parent = newType.parent || &quot;everything&quot;; if (this.typeIndex[name] !== undefined) { throw new TypeError(&quot;can't register type twice: &quot; + name); } this.typeIndex[name] = newType; var parentType = this.typeIndex[parent]; if (parentType === undefined) { throw new TypeError(`registerType couldn't find parent '${parent}' when adding type ${newType.type}`); } parentType.addSubtype(newType); newType.parent = parentType; // console.log (`Added ${newType.type} to ${parentType.type}`) } /** * Turns a thing (string, object, null, etc.) into a mandg type * @param thing {any} - the thing to find the type of, using the registered types */ resolveType(thing) { // recursively see if some 'type' in 'typeList' returns true when checking 'obj' // if it does, that's our type... check the subtypes to make sure there's not something // more specific function findType(typeList, obj) { var mandgList = _.map(typeList, function(m, t) { if (m === undefined || t === undefined) return; // console.log (&quot;typeof m:&quot;, typeof m); // console.log (&quot;m:&quot;, m); if (m.check(obj)) { return findType(m.subtype, obj) || m; } }); // type = _.flattenDeep (_.remove(type, _.isUndefined)); var mandg; _.remove(mandgList, _.isUndefined); if (mandgList.length &gt; 1) { throw new Error(&quot;found too many matching types&quot;); } if (mandgList.length === 0) mandg = undefined; if (Array.isArray(mandgList)) { mandg = _.flattenDeep(mandgList)[0]; } return mandg; } return findType(this.root.subtype, thing); } /** * Returns a context that every function should be called with */ getContext() { return this.callContext; } /** * Adds an item to the calling context for all MandG function calls * @param prop {string} - the new property in the context * @param val {any} - the value to assign to the property in the context */ addToContext(prop, val) { Object.defineProperty(this.callContext, prop, { writeable: false, configurable: true, enumerable: true, value: val }); // this.callContext[prop] = val; // TODO: configure as read only? } } module.exports = { // classes MandGTypeManager: MandGTypeManager, MandG: MandG, Mutator: Mutator, Generator: Generator }; × Search results Close "},"lodash-wrapper.js.html":{"id":"lodash-wrapper.js.html","title":"Source: lodash-wrapper.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Source: lodash-wrapper.js /** * @module lodash-wrapper * @description This is a simple wrapper for lodash that turns it into a singleton and extends * it with a Pseudo Random Number Generator (PRNG). The idea is that for any given seed, * the same random numbers will be used every time, enabling deterministic debugging for * any given seed. */ module.exports = (function() { var lodashSingleton; // saved _ var oldRandom; // saved Math.random // if lodash isn't loaded, loadit with our PRNG mixins if (lodashSingleton === undefined) { var seedrandom = require('seedrandom'); seedrandom(this.seed, { // XXX: replaces Math.random() with new PRNG, impacts lodash global: true, entropy: false }); // shim the Math.random object (mostly for debugging) oldRandom = Math.random; Math.random = __mathRandomShim; // load lodash with our new Math.random method lodashSingleton = require(&quot;lodash&quot;).runInContext(); // ensure we pick up a new context with the new nativeRandom // add our mixins lodashSingleton.mixin({ seedrandom: seedrandom }); lodashSingleton.mixin({ reseed: reseed }); } // reinitializes the PRNG function reseed(seed) { // re-seed PRNG lodashSingleton.seedrandom(seed, { global: true, entropy: false }); // update our shim oldRandom = Math.random; Math.random = __mathRandomShim; } // wrapper around seedrandom function __mathRandomShim() { // console.log (&quot;@#)($&amp; --- RANDOM --- @#(&amp;$@&quot;); return oldRandom(); } return lodashSingleton; })(); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Global Members mandgTypeManagerSingleton A singleton for managing all MandG types Source: mandg.js, line 203 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Modules Classes Cooker Fuzz Generator MandG MorGBase Mutator Recipe Step × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Classes Classes Cooker Fuzz Generator MandG MorGBase Mutator Recipe Step × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton js-fuzzing Fuzzing for JavaScript objects and functions Using an existing object or array of function arguments as a schema, and mutates or generates based on that schema. Extensible to add new types, mutators or generators. For more documentation see: http://apowers313.github.io/js-fuzzing/ Installationnpm install js-fuzz Use FuzzingTODO Fuzzing a ObjectTODO Fuzzing a FunctionTODO var FuzzGen = require(&quot;js-fuzzing&quot;); var options = { count: 1000, mutateChance: function() {}, generateChance: function() {}, selectChance: function() {}, allowedErrors: [ new Error (&quot;argument not allowed&quot;) ], passAllowed: false, timeout: false, argLimits: [ undefined, [&quot;!LargeNum&quot;, &quot;!ZeroNum&quot;] ] } var fg = new FuzzGen (); fg.fn (yourFunction, opts);Fuzzing a Set of FunctionsTODO Fuzzing a ConstructorTODO APIs for Extending FuzzingThere are three ways to extend the fuzzing functionality: registerType - Add a new type (Object, String, HexString, Base64EncodedString, etc.) registerMutator - Add a new mutator to an existing type registerGenerator - Add a new generator to an existing type registerTyperegisterType (name, obj, [parent]) name - A string for the name of the new type, all lower case and appropriate for being used as a key in an object (e.g. - &quot;hexstring&quot;, &quot;object&quot;, &quot;binaryarray&quot;) obj - An object describing the new type. It must contain a method check which takes any type and returns true / false based on whether the thing passed in is one of your type. Can also have an array of generate or mutate for the corresponding functions, described in registerMutator and registerGenerator below. An object of subtype will be created empty and added to as subtypes are registered. parent - An optional string describing the parent type. For example, &quot;array&quot;, &quot;date&quot;, and &quot;regexp&quot; all have a parent type of &quot;object&quot;. check is called by resolveType only one return type from resolveType called hierarchically -- whichever check call matches first and whichever of the subtypes matches under that type (or the parent type if none of the subtypes match) TODO registerMutatorTODO registerGeneratorTODO // TODO: new types: // - JSON // - JWT // - base64 // - hex // - ByteArray // - TypedArray // - arrayofbytes // - HTML × Search results Close "},"Cooker.html":{"id":"Cooker.html","title":"Class: Cooker","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Cooker Cooker takes a thing object and a bunch of random numbers and spits out a Recipe new Cooker(opts) Cooker constructor Parameters: Name Type Description opts object options for the new cooker Properties Name Type Description numPathsDistribution string when selecting the number of paths from thing to mangle, this is the distribution. Options are &quot;low&quot;, &quot;uniform&quot; or &quot;split&quot;. Low is more likely to pick a low number of paths (e.g. - 1 or 2), uniform is likely to pick any number of paths, and split is likely to pick a low number or the max number. Source: cooker.js, line 12 Methods init(thing) initializes the Cooker with a thing object and does any configuration necessary Parameters: Name Type Description thing any the object, string, array, null, or whatever that will be mangled by the fuzzer Source: cooker.js, line 42 × Search results Close "},"Fuzz.html":{"id":"Fuzz.html","title":"Class: Fuzz","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Fuzz Fuzz The main class for operating the Fuzzer new Fuzz(thing) Parameters: Name Type Description thing any the object, string, array, null, or whatever that will be mangled by the fuzzer Source: fuzz.js, line 19 × Search results Close "},"Generator.html":{"id":"Generator.html","title":"Class: Generator","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Generator Generator Generic Generator class new Generator() Source: mandg.js, line 61 × Search results Close "},"MandG.html":{"id":"MandG.html","title":"Class: MandG","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: MandG MandG Mutators and Generators (MandG) container class has all the logic around the specific mutators and generators for a specific type new MandG() Source: mandg.js, line 76 Methods borrowGenerator() Reuses a generator that has already been implemented by another module Source: mandg.js, line 158 borrowMutator() Reuses a mutator that has already been implemented by another module Source: mandg.js, line 167 filter() filters mutators and generators based on a specific tag Source: mandg.js, line 195 To Do: not implemented × Search results Close "},"module-lodash-wrapper.html":{"id":"module-lodash-wrapper.html","title":"Module: lodash-wrapper","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Module: lodash-wrapper This is a simple wrapper for lodash that turns it into a singleton and extends it with a Pseudo Random Number Generator (PRNG). The idea is that for any given seed, the same random numbers will be used every time, enabling deterministic debugging for any given seed. Source: lodash-wrapper.js, line 1 × Search results Close "},"MorGBase.html":{"id":"MorGBase.html","title":"Class: MorGBase","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: MorGBase MorGBase new MorGBase() Source: mandg.js, line 6 To Do: Mutator and Generator should be derived from a common class... too much cut-and-paste code right now × Search results Close "},"Mutator.html":{"id":"Mutator.html","title":"Class: Mutator","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Mutator Mutator Generic Mutator class new Mutator() Source: mandg.js, line 48 × Search results Close "},"Recipe.html":{"id":"Recipe.html","title":"Class: Recipe","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Recipe Recipe The recipe instructs the Fuzzer what steps to take to mutate a thing new Recipe() Source: cooker.js, line 180 Members length Get the number of steps in the recipe Source: cooker.js, line 196 Methods addStep(pathOrStep, op) Adds a step to this receipe Parameters: Name Type Description pathOrStep String | Step the path in thing that op will run on. Or if a Step has already been created (which constains a path and op) just use that instead. op function if pathOrStep is a path, this is the function that will be run against that path Source: cooker.js, line 205 × Search results Close "},"Step.html":{"id":"Step.html","title":"Class: Step","body":" JS Fuzzing Modules lodash-wrapper Classes CookerFuzzGeneratorMandGMorGBaseMutatorRecipeStep Global mandgTypeManagerSingleton Class: Step Step A single step in a Recipe new Step() Source: cooker.js, line 170 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
