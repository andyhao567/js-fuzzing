<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"docs_scripts_fulltext-search-ui.js.html":{"id":"docs_scripts_fulltext-search-ui.js.html","title":"Source: docs/scripts/fulltext-search-ui.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Source: docs/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(&quot;iframe&quot;)), body = $(&quot;body&quot;), self = this; quickSearch.attr(&quot;src&quot;, &quot;quicksearch.html&quot;); quickSearch.css(&quot;width&quot;, &quot;0px&quot;); quickSearch.css(&quot;height&quot;, &quot;0px&quot;); body.append(quickSearch); $(window).on(&quot;message&quot;, function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != &quot;docstrap.quicksearch.done&quot;) { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(&quot;value&quot;); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ &quot;searchTerms&quot;: searchTerms, &quot;msgid&quot;: &quot;docstrap.quicksearch.start&quot; }, &quot;*&quot;); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(&quot;#searchResults&quot;).find(&quot;.modal-body&quot;)), fragment = document.createDocumentFragment(), resultsList = document.createElement(&quot;ul&quot;); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(&quot;li&quot;), link = document.createElement(&quot;a&quot;); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(&quot;#searchResults&quot;).modal({&quot;show&quot;: true}); }; return new SearcherDisplay(); })($); × Search results Close "},"lib_cooker.js.html":{"id":"lib_cooker.js.html","title":"Source: lib/cooker.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Source: lib/cooker.js var _ = require(&quot;./lodash-wrapper.js&quot;); var pd = require(&quot;probability-distributions&quot;); var { MandG } = require(&quot;./mandg.js&quot;); /** * takes a `thing` object and a bunch of random numbers and * spits out a Recipe */ class Cooker { /** * Cooker constructor * @param {object} opts - options for the new cooker * @param {string} opts.numPathsDistribution - when selecting the number of paths from `thing` to mangle, this is the distribution. Options are &quot;low&quot;, &quot;uniform&quot; or &quot;split&quot;. Low is more likely to pick a low number of paths (e.g. - 1 or 2), uniform is likely to pick any number of paths, and split is likely to pick a low number or the max number. */ constructor(opts) { opts = opts || {}; var defaults = { numPathsDistribution: &quot;low&quot;, weightMap: new Map([ [&quot;generate&quot;, 3], [&quot;mutate&quot;, 3], [&quot;generateAll&quot;, 1], [&quot;mutateParent&quot;, 1] ]) }; _.defaultsDeep(opts, defaults); this.numPathsDistribution = opts.numPathsDistribution; this.weightMap = opts.weightMap; // calculated in init this.weightedOpList = []; } /** * initializes the Cooker with a `thing` object and does any configuration necessary * @param {any} thing - the object, string, array, null, or whatever that will be mangled by the fuzzer */ init(thing) { // save thing for later this.thing = _.cloneDeep(thing); // adds one entry of a function for every weight count for (let weightType of this.weightMap) { var weight = weightType[1]; var functionName = weightType[0]; for (let i = 0; i &lt; weight; i++) { this.weightedOpList.push(functionName); } } // create the path list this.pathList = _.invokeMap(traverse(thing).paths(), Array.prototype.join, &quot;.&quot;); // mark initialization as complete this.initialized = true; return this; } getRandomPathCount(max) { pd.prng = Math.random; // three options: switch (this.numPathsDistribution) { case &quot;uniform&quot;: // 1. uniform distribution return _.random(1, max); case &quot;low&quot;: // 2. low-number heavy distribution return pd.rbinom(1, max - 1, 0.1)[0] + 1; case &quot;split&quot;: // 3. split between min and max, with an even sprinkling inbetween return (Math.ceil(pd.rbeta(1, 0.5, 0.6)[0] * max - 1)) + 1; } } selectPaths(list) { if (list.length === 1) return list; var count = this.getRandomPathCount(list.length - 1); return _.sampleSize(list, count); } selectOp(mandg) { var op; var opGenerator; do { opGenerator = _.sample(this.weightedOpList); console.log(&quot;op gen:&quot;, opGenerator); this[opGenerator](mandg); } while (!op); return op; } generate(mandg) { return _.sample(mandg.generator); } mutate(mandg) { return _.sample(mandg.mutator); } generateAll() { throw new Error(&quot;generateAll not implemented&quot;); return _.sample(this.generateAllList); } mutateParent(mandg) { throw new Error(&quot;mutateParent not implemented&quot;); var mutateList = []; while (mandg) { mutateList.push(...mandg.mutators); mandg = mandg.parent; } return _.sample(mutateList); } createRecipe(thing, pathList, typeList) { if (!Array.isArray(pathList)) { throw new TypeError(&quot;createRecipe expected first arg to be pathList array, got:&quot;, pathList); } if (!Array.isArray(typeList)) { throw new TypeError(&quot;createRecipe expected second arg to be typeList array, got:&quot;, typeList); } var selectedPaths = this.selectPaths(pathList); var recipe = new Recipe(); for (let path of selectedPaths) { console.log(&quot;path&quot;); // extract the specific item from the path in the thing object var item = _.get(thing, path); // find the matching mandg for the thing var mandg = this.resolveType(item); // find the operation we want to perform var op = this.selectOp(path, mandg); recipe.addStep(path, op); } return recipe; } } /** * The recipe instructs the Fuzzer what steps to take to mutate a `thing` */ class Recipe { constructor() { // this.length this.steps = new Set(); // this.steps = [{path: &quot;&quot;, operation: &quot;&quot;}] } get length() { return this.steps.size; } addStep(path, op) { var step = { path: path, operation: op }; this.steps.add(step); } // toString } module.exports = { Cooker: Cooker, Recipe: Recipe }; × Search results Close "},"lib_fuzz.js.html":{"id":"lib_fuzz.js.html","title":"Source: lib/fuzz.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Source: lib/fuzz.js var _ = require(&quot;./lodash-wrapper&quot;); // var MandG = require(&quot;./mandg.js&quot;).MandG; var Cooker = require(&quot;./cooker.js&quot;); module.exports = Fuzz; /** * The main class for operating the Fuzzer * @param {any} thing - the object, string, array, null, or whatever that will be mangled by the fuzzer */ function Fuzz(thing, opts) { opts = opts || {}; var defaults = { seed: new Date().getTime(), cooker: new Cooker(), }; // resolve default values vs. passed in options _.defaultsDeep(opts, defaults); // reseed the PRNG _.reseed(this.seed); // save the 'thing' for later this.thing = _.cloneDeep(thing); // create the cooker this.cooker = opts.cooker; this.cooker.init(thing); } Fuzz.prototype.fn = function(fn, argArr, cnt) { }; Fuzz.prototype.fuzz = function() { var thing = _.cloneDeep(this.baseThing); var recipe = this.cooker.createRecipe(thing, this.pathList, this.types); for (let step of recipe) { console.log (step); } // if (this.singleBaseThing) return this.fuzzSingle(); // var thing = _.cloneDeep(this.baseThing); // console.log(thing); // var itemList = this.selectItems(this.pathList); // console.log(&quot;full path list:&quot;, this.pathList); // console.log(&quot;item list:&quot;, itemList); // var itemPath, itemType, item; // while (itemList.length) { // itemPath = itemList.pop(); // if (itemPath === &quot;&quot;) return this.fuzzSingle(); // // TODO: itemPath.split(&quot;.&quot;) // console.log(&quot;path:&quot;, itemPath); // item = _.get(thing, itemPath); // console.log(&quot;item:&quot;, item); // itemType = this.resolveType(item); // item = this.mutateOrGenerate(item, itemType); // console.log(item); // console.log(&quot;setting:&quot;, itemPath); // _.set(thing, itemPath, item); // console.log(&quot;new thang:&quot;, thing); // console.log(itemList.length); // } }; // Fuzz.prototype.fuzzSingle = function() { // console.log(&quot;fuzzSingle&quot;); // var thing = _.cloneDeep(this.baseThing); // var type = this.resolveType(thing); // console.log(&quot;Thing:&quot;, thing); // console.log(&quot;Type:&quot;, type); // return this.mutateOrGenerate(thing, type); // }; × Search results Close "},"lib_mandg.js.html":{"id":"lib_mandg.js.html","title":"Source: lib/mandg.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Source: lib/mandg.js var _ = require(&quot;./lodash-wrapper.js&quot;); var traverse = require(&quot;traverse&quot;); var DepGraph = require(&quot;dependency-graph&quot;).DepGraph; /** * Mutator * * Generic Mutator class */ class Mutator { constructor(name, fn, opts) { // check args if (typeof name !== &quot;string&quot;) { throw new TypeError(&quot;Mutator constructor expected 'name' to be string, got:&quot; + name); } if (typeof fn !== &quot;function&quot;) { throw new TypeError(&quot;Mutator constructor expected 'fn' to be function, got:&quot; + typeof fn); } if (fn.length !== 1) { throw new TypeError(&quot;Mutator constructor expected 'fn' to have zero args, has:&quot; + fn.length); } opts = opts || {}; this.tags = []; this.name = name; this.fn = fn; } fn(thing) { throw new Error(`Mutating ${thing} in ${this.name}: mutator not implemented`); } } /** * Generator * * Generic Generator class */ class Generator { constructor(name, fn, opts) { // check args if (typeof name !== &quot;string&quot;) { throw new TypeError(&quot;Generator constructor expected 'name' to be string, got:&quot; + name); } if (typeof fn !== &quot;function&quot;) { throw new TypeError(&quot;Generator constructor expected 'fn' to be function, got:&quot; + typeof fn); } if (fn.length !== 0) { throw new TypeError(&quot;Generator constructor expected 'fn' to have zero args, has:&quot; + fn.length); } opts = opts || {}; this.tags = []; this.name = name; this.fn = fn; } fn() { throw new Error(`Generator in ${this.name} not implemented`); } } /** * MandG * * Mutators and Generators (MandG) container class * has all the logic around the specific mutators and generators for a specific type */ class MandG { constructor(type, check, opts) { if (typeof type !== &quot;string&quot;) { throw new TypeError(&quot;MandG constructor expected type, got: &quot; + type); } if (typeof check !== &quot;function&quot;) { throw new TypeError(&quot;MandG constructor expected 'check' to be a function, got: &quot; + typeof check); } // set default options opts = opts || {}; var defaults = {}; _.defaultsDeep(opts, defaults); if (!Array.isArray (opts.depends) &amp;&amp; opts.depends !== undefined) { throw new TypeError (&quot;Expected dependencies to be array, got: &quot; + typeof opts.depends); } if (typeof opts.parent !== &quot;string&quot; &amp;&amp; opts.parent !== undefined) { throw new TypeError (&quot;Expected parent to be string, got: &quot; + typeof opts.parent); } this.depends = opts.depends || [] this.parent = opts.parent || undefined; // configure options this.type = type; this.name = type; this.check = check; // for future use // TODO: use Maps this.mutator = {}; this.generator = {}; this.subtype = {}; this.utils = {}; } check(thing) { throw new Error(`Adding ${thing}: check not implemented`); } addMutator(m) { // if mutator is a function, convert it to the mutator class if (typeof m === &quot;function&quot;) { m = new Mutator(m.name, m); } // check typeof Mutator if (!(m instanceof Mutator)) { throw new TypeError(&quot;addMutator expected type Mutator, got: &quot; + typeof m); } // TODO: check to make sure mutator doesn't already exist? var name = m.name; this.mutator[name] = m; } addGenerator(g) { // if generator is a function, convert it to the generator class if (typeof g === &quot;function&quot;) { g = new Generator(g.name, g); } // check typeof Generator if (!(g instanceof Generator)) { throw new TypeError(&quot;addGenerator expected type Generator, got: &quot; + typeof g); } // TODO: check to make sure generator doesn't already exist? var name = g.name; this.generator[name] = g; } addSubtype(s) { // check typeof Subtype if (!(s instanceof MandG)) { throw new TypeError(&quot;addSubtype expected type MandG, got: &quot; + typeof s); } if (s === this) { throw new TypeError(&quot;attempting to add MandG to itself: recursion not allowed&quot;); } // TODO: check to make sure type doesn't already exist var name = s.name; if (this.subtype[name] !== undefined) { throw new TypeError(&quot;trying to add duplicate subtype: &quot; + name); } this.subtype[name] = s; } /** * filter * * filters mutators and generators based on a specific tag */ filter(tag) {} } var mandgTypeManagerSingleton; class MandGTypeManager { constructor(opts) { // class is a singleton if (mandgTypeManagerSingleton) return mandgTypeManagerSingleton; mandgTypeManagerSingleton = this; // set default options opts = opts || {}; var defaults = { mandgModuleList: [&quot;array&quot;, &quot;boolean&quot;, &quot;date&quot;, &quot;function&quot;, /*&quot;null&quot;,*/ &quot;number&quot;, &quot;object&quot;, &quot;regexp&quot;, &quot;string&quot;, &quot;undef&quot;] }; _.defaultsDeep(opts, defaults); // a heirarchy of types this.typeIndex = {}; // a flat list of all types this.types = {}; // load all the built-in types if (opts.mandgReplacementModules) { this.mandgModuleList = opts.mandgReplacementModules; } else { this.mandgModuleList = opts.mandgModuleList; } var mandg; var dependencyGraph = new DepGraph(); for (let idx in this.mandgModuleList) { mandg = null; try { mandg = require(this.mandgModuleList[idx]); } catch (err) {} if (!mandg) try { mandg = require(`./types/${this.mandgModuleList[idx]}.js`); } catch (err) {} // if (!(mandg instanceof MandG)) { // XXX TODO for some reason this is broken if (!mandg) { throw TypeError(&quot;Error loading mandg module: &quot; + this.mandgModuleList[idx]); } // add the node to the dependency graph // note that all nodes have to exist before dependencies can be added dependencyGraph.addNode(mandg.type, mandg); } // map out dependencies // TODO: save this order? replace module list? var list = dependencyGraph.overallOrder(); for (let node of list) { mandg = dependencyGraph.getNodeData(node); // try to add parent as a dependency if (mandg.parent) { try { dependencyGraph.addDependency(mandg.type, mandg.parent); } catch (err) { throw new TypeError(`parent '${mandg.parent}' not found when loading '${mandg.type}'`); } } // try to add all depends as dependencies for (let depName of mandg.depends) { try { dependencyGraph.addDependency(mandg.type, depName); } catch (err) { throw new TypeError(`dependency '${depName}' not found when loading '${mandg.type}'`); } } } for (let node of dependencyGraph.overallOrder()) { mandg = dependencyGraph.getNodeData(node); this.registerType(mandg); } } /** * Kills the singleton so that a new one will be created. * Mostly useful for testing, but maybe other things too. */ forceReset() { mandgTypeManagerSingleton = null; } /** * registers a new mandg type */ registerType(newType) { if (!(newType instanceof MandG)) { throw new TypeError(&quot;expected 'newType' to be of type MandG, was: &quot; + typeof mandg); } var name = newType.type; var parent = newType.parent; if (this.typeIndex[name] !== undefined) { throw new TypeError(&quot;can't register type twice: &quot; + name); } this.typeIndex[name] = newType; if (parent === undefined) { this.types[name] = newType; } else { var parentType = this.typeIndex[parent]; if (parentType === undefined) { throw new TypeError(`registerType couldn't find parent '${parent}' when adding type ${newType.type}`); } parentType.addSubtype(newType); newType.parent = parentType; } } /** * Turns a thing (string, object, null, etc.) into a mandg type */ resolveType(thing) { // recursively see if some 'type' in 'typeList' returns true when checking 'obj' // if it does, that's our type... check the subtypes to make sure there's not something // more specific function findType(typeList, obj) { var mandgList = _.map(typeList, function(m, t) { if (m === undefined || t === undefined) return; if (m.check(obj)) { return findType(m.subtype, obj) || m; } }); // type = _.flattenDeep (_.remove(type, _.isUndefined)); var mandg; _.remove(mandgList, _.isUndefined); if (mandgList.length &gt; 1) { throw new Error(&quot;found too many matching types&quot;); } if (mandgList.length === 0) mandg = undefined; if (Array.isArray(mandgList)) { mandg = _.flattenDeep(mandgList)[0]; } return mandg; } return findType(this.types, thing); } } module.exports = { // classes MandGTypeManager: MandGTypeManager, MandG: MandG, Mutator: Mutator, Generator: Generator }; × Search results Close "},"lib_lodash-wrapper.js.html":{"id":"lib_lodash-wrapper.js.html","title":"Source: lib/lodash-wrapper.js","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Source: lib/lodash-wrapper.js /** * @module lodash-wrapper * @description This is a simple wrapper for lodash that turns it into a singleton and extends * it with a Pseudo Random Number Generator (PRNG). The idea is that for any given seed, * the same random numbers will be used every time, enabling deterministic debugging for * any given seed. */ module.exports = (function() { var lodashSingleton; // saved _ var oldRandom; // saved Math.random // if lodash isn't loaded, loadit with our PRNG mixins if (lodashSingleton === undefined) { var seedrandom = require('seedrandom'); seedrandom(this.seed, { // XXX: replaces Math.random() with new PRNG, impacts lodash global: true, entropy: false }); // shim the Math.random object (mostly for debugging) oldRandom = Math.random; Math.random = __mathRandomShim; // load lodash with our new Math.random method lodashSingleton = require(&quot;lodash&quot;).runInContext(); // ensure we pick up a new context with the new nativeRandom // add our mixins lodashSingleton.mixin({ seedrandom: seedrandom }); lodashSingleton.mixin({ reseed: reseed }); } // reinitializes the PRNG function reseed(seed) { // re-seed PRNG lodashSingleton.seedrandom(seed, { global: true, entropy: false }); // update our shim oldRandom = Math.random; Math.random = __mathRandomShim; } // wrapper around seedrandom function __mathRandomShim() { // console.log (&quot;@#)($&amp; --- RANDOM --- @#(&amp;$@&quot;); return oldRandom(); } return lodashSingleton; })(); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Global Methods Fuzz(thing) The main class for operating the Fuzzer Parameters: Name Type Description thing any the object, string, array, null, or whatever that will be mangled by the fuzzer Source: lib/fuzz.js, line 12 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Modules Classes Cooker Generator MandG Mutator Recipe × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Classes Classes Cooker Generator MandG Mutator Recipe × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz js-fuzzingFuzzing for JavaScript objects and functions Using an existing object or array of function arguments as a schema, and mutates or generates based on that schema. Extensible to add new types, mutators or generators. Installationnpm install js-fuzz Use FuzzingTODO Fuzzing a ObjectTODO Fuzzing a FunctionTODO var FuzzGen = require(&quot;js-fuzzing&quot;); var options = { count: 1000, mutateChance: function() {}, generateChance: function() {}, selectChance: function() {}, allowedErrors: [ new Error (&quot;argument not allowed&quot;) ], passAllowed: false, timeout: false, argLimits: [ undefined, [&quot;!LargeNum&quot;, &quot;!ZeroNum&quot;] ] } var fg = new FuzzGen (); fg.fn (yourFunction, opts);Fuzzing a Set of FunctionsTODO Fuzzing a ConstructorTODO APIs for Extending FuzzingThere are three ways to extend the fuzzing functionality: registerType - Add a new type (Object, String, HexString, Base64EncodedString, etc.) registerMutator - Add a new mutator to an existing type registerGenerator - Add a new generator to an existing type registerTyperegisterType (name, obj, [parent]) name - A string for the name of the new type, all lower case and appropriate for being used as a key in an object (e.g. - &quot;hexstring&quot;, &quot;object&quot;, &quot;binaryarray&quot;) obj - An object describing the new type. It must contain a method check which takes any type and returns true / false based on whether the thing passed in is one of your type. Can also have an array of generate or mutate for the corresponding functions, described in registerMutator and registerGenerator below. An object of subtype will be created empty and added to as subtypes are registered. parent - An optional string describing the parent type. For example, &quot;array&quot;, &quot;date&quot;, and &quot;regexp&quot; all have a parent type of &quot;object&quot;. check is called by resolveType only one return type from resolveType called hierarchically -- whichever check call matches first and whichever of the subtypes matches under that type (or the parent type if none of the subtypes match) TODO registerMutatorTODO registerGeneratorTODO // TODO: new types: // - JSON // - JWT // - base64 // - hex // - ByteArray // - TypedArray // - arrayofbytes // - HTML × Search results Close "},"Cooker.html":{"id":"Cooker.html","title":"Class: Cooker","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Class: Cooker Cooker takes a thing object and a bunch of random numbers and spits out a Recipe new Cooker(opts) Cooker constructor Parameters: Name Type Description opts object options for the new cooker Properties Name Type Description numPathsDistribution string when selecting the number of paths from thing to mangle, this is the distribution. Options are &quot;low&quot;, &quot;uniform&quot; or &quot;split&quot;. Low is more likely to pick a low number of paths (e.g. - 1 or 2), uniform is likely to pick any number of paths, and split is likely to pick a low number or the max number. Source: lib/cooker.js, line 11 Methods init(thing) initializes the Cooker with a thing object and does any configuration necessary Parameters: Name Type Description thing any the object, string, array, null, or whatever that will be mangled by the fuzzer Source: lib/cooker.js, line 41 × Search results Close "},"Generator.html":{"id":"Generator.html","title":"Class: Generator","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Class: Generator Generator Generator Generic Generator class new Generator() Source: lib/mandg.js, line 39 × Search results Close "},"MandG.html":{"id":"MandG.html","title":"Class: MandG","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Class: MandG MandG MandG Mutators and Generators (MandG) container class has all the logic around the specific mutators and generators for a specific type new MandG() Source: lib/mandg.js, line 69 Methods filter() filter filters mutators and generators based on a specific tag Source: lib/mandg.js, line 166 × Search results Close "},"module-lodash-wrapper.html":{"id":"module-lodash-wrapper.html","title":"Module: lodash-wrapper","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Module: lodash-wrapper This is a simple wrapper for lodash that turns it into a singleton and extends it with a Pseudo Random Number Generator (PRNG). The idea is that for any given seed, the same random numbers will be used every time, enabling deterministic debugging for any given seed. Source: lib/lodash-wrapper.js, line 1 × Search results Close "},"Mutator.html":{"id":"Mutator.html","title":"Class: Mutator","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Class: Mutator Mutator Mutator Generic Mutator class new Mutator() Source: lib/mandg.js, line 10 × Search results Close "},"Recipe.html":{"id":"Recipe.html","title":"Class: Recipe","body":" JS Fuzzing Modules lodash-wrapper Classes CookerGeneratorMandGMutatorRecipe Global Fuzz Class: Recipe Recipe The recipe instructs the Fuzzer what steps to take to mutate a thing new Recipe() Source: lib/cooker.js, line 147 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
